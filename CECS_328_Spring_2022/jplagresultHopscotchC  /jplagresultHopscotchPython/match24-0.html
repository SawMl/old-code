<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>575384648</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>studentsolver.py</CENTER></H3><HR>
<PRE>
import itertools


def SS(top, bottom):
    startposition=''
    for elem in range(len(top)-1):
        # start at bottom end at bottom
        tBpair = bottom[elem] + bottom[elem + 1]
        # start at top end at top
        tPair = elem + top[elem + 1]
        # start at bottom end at top
        bPair = elem + bottom[elem + 1]
        # start at top end at bottom
        bTpair = bottom[elem] + top[elem+1]
        if bPair &gt; tPair and bPair &gt; tBpair and bPair &gt; bTpair:
            start = elem
            stop = elem-1
            startPosition = 'b'
        elif tPair &gt; bPair and tPair &gt; tBpair and tPair &gt; bTpair:
            start = elem
            stop = elem-1
            startPosition = 't'
        elif tBpair &gt; bPair and tBpair &gt; tPair and tBpair &gt; bTpair:
            start = elem
            stop = elem-1
            startPosition = 'tB'
        elif bTpair &gt; bPair and bTpair &gt; tBpair and bTpair &gt; tPair:
            start = elem
            stop = elem-1
            startPosition = 'bT'
        else:
            continue
    print(start, stop, startPosition)
    return start, stop, startPosition
# def bT(grid,x,y,):
#     for elem in range(len(grid[0])):
#         zero = grid[y][x+1]
#         un = grid[y+1][x+1]
#         negun = grid[y - 1][x + 1]
#         if zero &gt; un and zero &gt; negun:
#             # w += 1
#             return 0
#         elif un &gt; zero and un &gt; negun:
#             # w += 1
#             return 1
#         elif negun &gt; zero and negun &gt; un:
#             # w += 1
#             return-1
#         elif zero == un:
#             zero = G[startRow + h][start + w + 1]
#             un = G[startRow + h + 1][start + w + 1]
#         elif negun == zero:
#         elif un == negun:

def bT(start, stop, startPosition, grid, solution,width,height):
    if startPosition == 'bT':
        startRow = 0
        G = grid[startRow][start]
        E = grid[-1][stop]
        solution.append(0)
        solution.append(start)
        ans = []
        h=0
        for w in range(width-1):
            while G != E:
                zero = grid[startRow + h][start + w + 1]
                un = grid[startRow + h + 1][start + w + 1]
                negun = grid[startRow + h - 1][start + w + 1]
                x=start+w
                y=startRow+h
                result=bT(grid,x,y)
                choice=result[0]
                num=result[1]
                if choice == 0  and w &lt; width:
                    #w += 1
                    solution.append(0)
                elif un &gt; zero and un &gt; negun:
                    #w += 1
                    h -= 1
                    solution.append(1)
                elif negun &gt; zero and negun &gt; un:
                    #w += 1
                    h += 1
                    solution.append(-1)



# def A_n_k(a, grid, depth, used, curr, ans):
#     '''
#     Implement permutation of k items out  of n items
#     depth: start from 0, and represent the depth of the search
#     used: track what items are  in the partial solution from the set of n
#     curr: the current partial solution
#     ans: collect all the valide solutions
#     '''
#     k=len(grid[0])
#     if depth == k:  # end condition
#         ans.append(curr[::])  # use deepcopy because curr is tracking all partial solution, it eventually become []
#         return
#
#     for i in range(7):
#         if not used[i]:
#             # generate the next solution from curr
#             curr.append(a[i])
#             used[i] = True
#             print(curr)
#             # move to the next solution
#             A_n_k(a, grid, depth + 1, used, curr, ans)
#
#             # backtrack to previous partial state
#             curr.pop()
#             print('backtrack: ', curr)
#             used[i] = False
#     return
#
# def combinations(iterable, r):
#     # combinations('ABCD', 2) --&gt; AB AC AD BC BD CD
#     # combinations(range(4), 3) --&gt; 012 013 023 123
#     pool = tuple(iterable)
#     n = len(pool)
#     if r &gt; n:
#         return
#     indices = range(r)
#     yield tuple(pool[i] for i in indices)
#     while True:
#         for i in reversed(range(r)):
#             if indices[i] != i + n - r:
#                 break
#         else:
#             return
#         indices[i] += 1
#         for j in range(i+1, r):
#             indices[j] = indices[j-1] + 1
#         yield tuple(pool[i] for i in indices)

def solve(grid):
    solution=[]
    y =0
    x =0
    h=len(grid)
    w=len(grid[0])
    print(&quot;height &quot;, h, &quot; width &quot;, w)
    print(grid[0])
    print(grid[-1])
    result=SS(grid[0],grid[-1])
    start=result[0]
    stop=result[1]
    startPosition=result[2]
    # print(grid)
    # for i in range(start):
    #     temp=grid[0][0]
    #     grid.pop()
    #     grid.append(temp)
    # print(grid)
    # print('hi')
    if startPosition == 'b':
        startRow = -1
        G = grid[startRow][start]
        E = grid[-1][stop]
        solution.append(0)
        solution.append(start)
<A NAME="0"></A>        for elem in range(w-1):
            if start+x &gt;= w-1:
                i=start+x-w
                zero <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match24-1.html#0',3,'match24-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= grid[y][i + 1]
                un = grid[y - 1][i + 1]
                negun = grid[y + 1][i + 1]
            else:
                zero = grid[y][</B></FONT>start+x+1]
                un = grid[y-1][start+x+1]
                negun = grid[y+1][start+x + 1]
            if zero &gt;= un and zero &gt;= negun:
                x += 1
                solution.append(0)
            elif negun &gt;= zero and negun &gt;= un:
                w += 1
                y+=1
                solution.append(-1)
            elif un &gt;= zero and un &gt;= negun:
                x += 1
                y -= 1
                solution.append(1)
        print(solution)
        return solution
    if startPosition == 't':
        startRow = 0
        G = grid[startRow][start]
        E = grid[0][stop]
        solution.append(1)
        solution.append(start)
<A NAME="1"></A>        for elem in range(w-1):
            if start+x &gt;= w-1:
                i=start+x-w
                zero <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match24-1.html#1',3,'match24-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= grid[y][i + 1]
                un = grid[y - 1][i + 1]
                negun = grid[y + 1][i + 1]
            else:
                zero = grid[y][</B></FONT>start+x+1]
                un = grid[y-1][start+x+1]
                negun = grid[y+1][start+x + 1]
            if zero &gt;= un and zero &gt;= negun:
                x += 1
                solution.append(0)
            elif negun &gt;= zero and negun &gt;= un:
                w += 1
                y+=1
                solution.append(-1)
            elif un &gt;= zero and un &gt;= negun:
                x += 1
                y -= 1
                solution.append(1)
        print(solution)
        return solution
    if startPosition == 'tB':
        startRow = -1
        G = grid[startRow][start]
        E = grid[0][stop]
        solution.append(1)
        solution.append(start)
        for elem in range(w-1):
            if start+x &gt;= w-1:
                i=start+x-w
                zero = grid[y][i + 1]
                un = grid[y - 1][i + 1]
                negun = grid[y + 1][i + 1]
            else:
                zero = grid[y][start+x+1]
                un = grid[y-1][start+x+1]
                negun = grid[y+1][start+x + 1]
            if zero &gt;= un and zero &gt;= negun:
                x += 1
                solution.append(0)
            elif negun &gt;= zero and negun &gt;= un:
                w += 1
                y+=1
                solution.append(-1)
            elif un &gt;= zero and un &gt;= negun:
                x += 1
                y -= 1
                solution.append(1)
        print(solution)
        return solution
    if startPosition == 'bT':
        startRow = 0
        G = grid[startRow][start]
        E = grid[-1][stop]
        solution.append(1)
        solution.append(start)
        for elem in range(w-1):
            if start+x &gt;= w-1:
                i=start+x-w
                zero = grid[y][i + 1]
                un = grid[y - 1][i + 1]
                negun = grid[y + 1][i + 1]
            else:
                zero = grid[y][start+x+1]
                un = grid[y-1][start+x+1]
                negun = grid[y+1][start+x + 1]
            if zero &gt;= un and zero &gt;= negun:
                x += 1
                solution.append(0)
            elif negun &gt;= zero and negun &gt;= un:
                w += 1
                y+=1
                solution.append(-1)
            elif un &gt;= zero and un &gt;= negun:
                x += 1
                y -= 1
                solution.append(1)
        print(solution)
        return solution

test = [[3, 4, 1, 2, 8, 6],
[6, 1, 8, 2, 7, 4],
[5, 4, 3, 9, 9, 5],
[5, 9, 8, 3, 2, 6],
[8, 7, 2, 9, 6, 4]]

solve(test)
</PRE>

</BODY>
</HTML>
