<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>401627990</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>studentsolver.py</CENTER></H3><HR>
<PRE>
import copy
# import math

# restarter = False

class Node:
    def __init__(self, n):
        self.node = n
        # self.rows = r
        # self.newIndex = i
        self.up = None
        self.side = None
        self.down = None
        self.row = None
        self.column = None
        self.mobius = None
        self.conntected2Start = False
        self.Testanswer = []

        self.revUp = None
        self.revSide = None
        self.revDown = None
        self. moved = None

        # self.colLast = len(nextCoulmn) - 1
        # self.getNext(nextCoulmn, i)

        self.updatedNode = -100
        # self.doTheMaths()


    # def getAnswer(self):

    def __repr__(self):
        toStr = &quot;= Node: &quot; + str(self.node) + &quot; =\n&quot; + &quot; Up: &quot; + str((self.up).node) + &quot;\n Side: &quot; + str((self.side).node) + &quot;\n Down: &quot;+ str((self.down).node) + &quot;\n&quot;
        return toStr

    def restart(self):
        self.Testanswer = []
        self.updatedNode = -100
        self.moved = None

    def add2array(self):
        return [self.up, self.side, self.down]

    def lastColstart(self, last):
        # print(self.node, &quot;+&quot;, last.node)
        if self.up == last:
            # self.updatedNode = self.node + self.up.node
            # self.moved = 1
            temp = self.node + self.up.node
            if temp &gt; self.updatedNode:
                self.updatedNode = temp
                self.moved = 1
        elif self.side == last:
            # self.updatedNode = self.node + self.side.node
            # self. moved = 0
            temp = self.node + self.side.node
            if temp &gt; self.updatedNode:
                self.updatedNode = temp
                self.moved = 0
        elif self.down == last:
            # self.updatedNode = self.node + self.down.node
            # self.moved = -1
            temp = self.node + self.down.node
            if temp &gt; self.updatedNode:
                self.updatedNode = temp
                self.moved = -1
        self.Testanswer.insert(0, self.moved)


    #
    # def getNext(self, next, i):
    #     if i == 0:
    #         self.up = next[-1]
    #         self.side = next[i]
    #         self.down = next[i + 1]
    #         self.mobius = True
    #     elif i == (self.rows - 1):
    #         self.up = next[i - 1]
    #         self.side = next[i]
    #         self.down = next[0]
    #         self.mobius = False
    #     else:
    #         self.up = next[i - 1]
    #         self.side = next[i]
    #         self.down = next[i + 1]
    #         self.mobius = True

    def getMax(self):
        temp = [self.up, self.side, self.down]
        return max(temp)

    def getMaxPosition(self):
        temp1 = {1: self.up, 0: self.side, -1: self.down}
        temp = {1: self.up.updatedNode, 0: self.side.updatedNode, -1: self.down.updatedNode}
        self.position = max(temp, key=temp.get)
        # if self.position == -1:
        #     if self.mobius == False:
        #         # self.newIndex = 0
        #     else:
        #         # self.newIndex += 1
        # elif self.position == 1:
        #     if self.mobius == True:
        #         # self.newIndex = self.colLast
        #     else:
        #         # self.newIndex -= 1

        temppy = self.node + temp.get(self.position)
        if temppy &gt; self.updatedNode:
            self.updatedNode = temppy
            self.moved = self.position

        # self.moved = self.position
        # self.updatedNode = self.node + temp.get(self.position)
        self.Testanswer = copy.copy(temp1.get(self.position).Testanswer)
        self.Testanswer.insert(0, self.moved)
        if len(self.Testanswer) == 4:
            pass
        # self.Testanswer.append(self.moved)
        # self.Testanswer.append([self.moved, (temp1.get(self.position)).Testanswer, temp1.get(self.position).node])
        return self.updatedNode, self.position

    def doTheMaths(self):
        self.updatedNode = self.node + self.getMax()


def getStartb(grid):
    return grid[0][4], 0, 4

def sudoTreeIndex(grid, torb, col, numCol, numRow):
    temp = []
    tree = []
    tempColInd = None
    if torb == 0:
        #bottom
        torb = -1
        tempColInd = numRow - 1
    else:
        #top
        torb = 0
        tempColInd= 0

    # tree.append([Node(grid[tempColInd][col], columnGetter(grid, col+1), tempColInd, numRow)])
    #
    # helper = 3
    # for i in range(col + 1, numCol):
    #     for i in range(1, helper +1):
    #         print(i)
    #     helper += 2
    #
    # for i in range(0, col):
    #     top = math.ceil(helper/2)
    #     bot = helper - top
    #     for i in range(0, helper):
    #
    #         math.ceil(helper/2)
    #         print(i)
    #     helper += 2

    #     if i == numCol - 1:
    #         Node(grid[torb][i], columnGetter(grid, 0), 0, rows)
    #     else:
    #         pass
    #
    for i in range(0, col):
        pass


    return tree

# for i in range(4, columns):
#     print(&quot;-- Column: &quot;, i, &quot; --&quot;)
#     if i == columns - 1:
#         test = Node(grid[0][i], columnGetter(grid, 0), 0, rows)
#     else:
#         test = Node(grid[0][i], columnGetter(grid, i+1), 0, rows)
#     print(test)
#     print(&quot;Max Position: &quot;, test.getMaxPosition())
#
# for i in range(0, 4):
#     print(&quot;-- Column: &quot;, i, &quot; --&quot;)
#     test = Node(grid[0][i], columnGetter(grid, i + 1), 0, rows)
#     print(test)
#     print(&quot;Max Position: &quot;, test.getMaxPosition())
#

def columnGetter(grid, i):
    return [row[i] for row in grid]

def turnintocolumns(grid):
    temp = []
    for i in range(0, len(grid[0])):
        temp.append([row[i] for row in grid])
    return temp

def NextcolumnGetter(columns, currentIndex, numCol):
    if currentIndex == numCol - 1:
        return columns[0]
    else:
        return columns[currentIndex + 1]

def bottomsUp():
    pass

def getNext(node: Node, next, indexinCol, numRows):
    if indexinCol == 0:
        node.up = next[-1]
        node.side = next[indexinCol]
        node.down = next[indexinCol + 1]

        node.up.revUp = node
        node.side.revSide = node
        node.down.revDown = node

        node.mobius = True
    elif indexinCol == (numRows - 1):
        node.up = next[indexinCol - 1]
        node.side = next[indexinCol]
        node.down = next[0]
        node.mobius = False

        node.up.revUp = node
        node.side.revSide = node
        node.down.revDown = node
    else:
        node.up = next[indexinCol - 1]
        node.side = next[indexinCol]
        node.down = next[indexinCol + 1]

        node.up.revUp = node
        node.side.revSide = node
        node.down.revDown = node

def solve(grid):
    rows = len(grid)
    columns = len(grid[0])



    # actualNode, row, col = getStartb(grid)
    # start = Node(actualNode, columnGetter(grid, row + 1), 0, rows)
    # print(start)

    #
    # Traverse columns backwards from start
    # (change 4 when figure out how to get the start)
    startColIndex = 4
    lowIndex = columns
    index = startColIndex

    matrixOfNode = []
    tempRowIndex = 0

    for i in grid:
        tempColIndex = 0
        test = []

        for k in i:
            # nextCol = NextcolumnGetter(columnsGrid, tempColIndex, columns)
            temp = Node(k)
            temp.row = tempRowIndex
            temp.column = tempColIndex
            # getNext(temp, nextCol, tempRowIndex, rows)
            test.append(temp)
            tempColIndex += 1

        matrixOfNode.append(test)
        tempRowIndex += 1

    columnsGrid = turnintocolumns(matrixOfNode)
    tempRowIndex = 0
    for i in matrixOfNode:
        tempColIndex = 0
        for k in i:
            nextCol = NextcolumnGetter(columnsGrid, tempColIndex, columns)
            getNext(k, nextCol, tempRowIndex, rows)
            tempColIndex += 1

        tempRowIndex += 1

    allSumms = []
    corresponding = []


    ##colum index 4 is last
    for p in range(0, columns):
        tempStart = -10000


        for i in matrixOfNode:
            for k in i:
                k.restart()
        if p == 0:
            tempStart = columns - 1
<A NAME="0"></A>        else:
            tempStart = p - 1
<A NAME="1"></A>
        matrixOfNode[0][tempStart].revUp.lastColstart(matrixOfNode<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match81-1.html#0',3,'match81-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[0][tempStart])
        matrixOfNode[0][tempStart].revSide.lastColstart(matrixOfNode[0][tempStart])
        matrixOfNode[0][tempStart].revDown.</B></FONT>lastColstart(matrixOfNode<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match81-1.html#1',3,'match81-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[0][tempStart])

        matrixOfNode[-1][tempStart].revUp.lastColstart(matrixOfNode[-1][tempStart])
        matrixOfNode[-1][tempStart].revSide.</B></FONT>lastColstart(matrixOfNode[-1][tempStart])
        matrixOfNode[-1][tempStart].revDown.lastColstart(matrixOfNode[-1][tempStart])
        # print(matrixOfNode[0][tempStart].Testanswer)
        startCol = p
        startNodeUp = matrixOfNode[0][startCol]
        startNodeDown = matrixOfNode[-1][startCol]

        moveArray = []

        if startCol &gt;= 2:
            for i in reversed(range(0, startCol - 2)):
                temp = columnsGrid[i]
                for k in temp:
                    sum, move = k.getMaxPosition()
                    moveArray.append(move)

            for i in reversed(range(startCol, columns)):
                temp = columnsGrid[i]
                for k in temp:
                    sum, move = k.getMaxPosition()
                    # print(k)
                    # print(&quot;sum: &quot;, sum)
                    moveArray.append(move)

        elif startCol == 1:
            for i in reversed(range(startCol, columns - 1)):
                temp = columnsGrid[i]
                for k in temp:
                    move = k.getMaxPosition()
                    moveArray.append(move)
            #
            # for i in reversed(range(startCol, columns)):
            #     temp = columnsGrid[i]
            #     for k in temp:
            #         sum, move = k.getMaxPosition()
            #         # print(k)
            #         # print(&quot;sum: &quot;, sum)
            #         moveArray.append(move)
        elif startCol == 0:
            for i in reversed(range(0, columns - 2)):
                temp = columnsGrid[i]
                for k in temp:
                    move = k.getMaxPosition()
                    moveArray.append(move)
            #
            # for i in reversed(range(startCol, columns)):
            #     temp = columnsGrid[i]
            #     for k in temp:
            #         sum, move = k.getMaxPosition()
            #         # print(k)
            #         # print(&quot;sum: &quot;, sum)
            #         moveArray.append(move)

        # print(&quot;Start:&quot;, matrixOfNode[0][4].Testanswer, &quot;sum = &quot;, matrixOfNode[0][4].updatedNode)
        # print(&quot;End:&quot;, matrixOfNode[-1][4].Testanswer, &quot;sum = &quot;, matrixOfNode[-1][4].updatedNode)
        if matrixOfNode[0][startCol].updatedNode &gt; matrixOfNode[-1][startCol].updatedNode:
            allSumms.append(matrixOfNode[0][startCol].updatedNode)
            temp = copy.copy(matrixOfNode[0][startCol].Testanswer)
            temp.insert(0, startCol)
            temp.insert(0, 1)
            corresponding.append(temp)
            # print(&quot;Start:&quot;, temp, &quot;sum = &quot;, matrixOfNode[0][startCol].updatedNode)
        else:
            allSumms.append(matrixOfNode[0][startCol].updatedNode)
            temp = copy.copy(matrixOfNode[0][startCol].Testanswer)
            temp.insert(0, startCol)
            temp.insert(0, 0)
            corresponding.append(temp)
            # print(&quot;End:&quot;, matrixOfNode[-1][startCol].Testanswer, &quot;sum = &quot;, matrixOfNode[-1][startCol].updatedNode)
        restarter = True
        # print(corresponding)
        hack = corresponding[allSumms.index(max(allSumms))]
        if len(hack) &gt; columns + 1:
            hack.pop()
        # print(columnsGrid[10][-1].updatedNode)
    return hack
    # print(corresponding[allSumms.index(max(allSumms))])
    # print(matrixOfNode[0][3].node)
    # print(matrixOfNode[0][3].revUp.updatedNode)


    # columnsGrid[-1]


    # print(matrixOfNode[-1])
    # print(columnsGrid[0])

    # for i in

    # 0: Bottom
    # 1: Top
    # torb = 1
    # # (change 4 when figure out how to get the start)
    # startColIndex = 4
    # tree = sudoTreeIndex(grid, torb, startColIndex, columns, rows)
    # print(tree, &quot;\n=========&quot;)

    # print(&quot;Number of columns: &quot;, columns, &quot;Start @ column index: &quot;, startColIndex)

    # #start with lowest layer possible
    # if startColIndex ==  0:
    #     lowIndex = columns - 2
    #     lowIndexm1 = lowIndex + 1
    #     # lowestLayer = columnGetter(grid, (columns - 2))
    # elif startColIndex == 1:
    #     lowIndex = columns - 1
    #     lowIndexm1 = 0
    #     # lowestLayer = columnGetter(grid, (columns - 1))
    # else:
    #     lowIndex = startColIndex - 2
    #     lowIndexm1 = lowIndex + 1
    #
    # lowestLayer = columnGetter(grid, lowIndex)
    # colIndex = 0
    # for i in lowestLayer:
    #     noCalctree.append(Node(i, columnGetter(grid, lowIndexm1), colIndex, rows))
    #     colIndex += 1
    #
    # print(lowestLayer)
    #
    # for i in noCalctree:
    #     print(i)
    #     print(i.updatedNode)

    # print(noCalctree)
    ############################
    # Traverse row
    #
    # for i in range(4, columns):
    #     print(&quot;-- Column: &quot;, i, &quot; --&quot;)
    #     if i == columns - 1:
    #         test = Node(grid[0][i], columnGetter(grid, 0), 0, rows)
    #     else:
    #         test = Node(grid[0][i], columnGetter(grid, i+1), 0, rows)
    #     print(test)
    #     print(&quot;Max Position: &quot;, test.getMaxPosition())
    #
    # for i in range(0, 4):
    #     print(&quot;-- Column: &quot;, i, &quot; --&quot;)
    #     test = Node(grid[0][i], columnGetter(grid, i + 1), 0, rows)
    #     print(test)
    #     print(&quot;Max Position: &quot;, test.getMaxPosition())

    # print(start)



    # print(rows, &quot;x&quot;, columns)




#
# instEX = [[3, 4, 1, 2, 8, 6],
#           [6, 1, 8, 2, 7, 4],
#           [5, 4, 3, 9, 9, 5],
#           [5, 9, 8, 3, 2, 6],
#           [8, 7, 2, 9, 6, 4]]
#
# test1 = [[9, 3, 7, 8, 7],
#         [1, 8, 5, 6, 4],
#         [3, 8, 2, 3, 2],
#         [6, 1, 9, 3, 2],
#         [1, 8, 3, 1, 3]]
#
# #12 col
# test3 = [[9, 8, 1, 4, 8, 8, 6, 2, 9, 6, 1, 3],
# [8, 2, 6, 5, 4, 3, 2, 6, 7, 2, 3, 7],
# [8, 2, 7, 7, 2, 7, 6, 2, 3, 1, 9, 7],
# [5, 3, 5, 5, 9, 1, 4, 3, 4, 6, 5, 7],
# [9, 4, 1, 8, 9, 7, 3, 9, 5, 4, 3, 8],
# [8, 6, 3, 4, 4, 3, 8, 7, 5, 4, 1, 1],
# [7, 8, 4, 4, 6, 9, 3, 5, 7, 6, 6, 7],
# [6, 3, 8, 7, 1, 2, 9, 8, 9, 5, 7, 8]]
#
# t1 = [  [2, 8, 1, 3],
#         [3, 8, 5, 5],
#         [8, 7, 6, 3],
#         [1, 8, 6, 1],
#         [8, 4, 6, 5]]
#
# print(solve(test3))
</PRE>

</BODY>
</HTML>
